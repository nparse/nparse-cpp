import function.ext.ng;

S := (	boolean		, ^.+ { value = boolean($); }
	||	integer		, ^.+ { value = integer($); }
	||	real		, ^.+ { value = real($); }
	||	string		, ^.+ { value = string($); }
	||	array		, ^.+ { value = array($); }
	||	pass		, ^.+ :arg $testPass
	||	stop		, ^.+ :arg $testStop
	||	len			, ^.* :arg { value = len($); }
	||	self		, <R:testSelf {n}>
	||	ext			, <R:testExt>
	||	ref			, <R:testRef>
	||	call		, <R:testCall>
	||	call-ref	, <R:testCallRef>
	||	call-call	, <R:testCallCall>
	||	swap		, <R:testSwap>
	||	nth			, <R:testNth>
	) ^$;

testPass {
	skip = true;
	pass( arg == exp );	// Passes the rest of the action
						// if the condition is satisfied.
	skip = false;
};

testStop {
	stop( arg == exp );	// Interrups the action as well as any consequent
						// iterations if the condition is satisfied.
};

testSelf :=
	{ items = {}; count = 0; }
	(^[^,\s]+ { items[++count] = $; }) % ^\s*,\s*
	{ self({value: items[n]}); };

func fx (_a, _b) {
	fx = "[$_a*$_b]";
};

testExt :=
	^\w+ ^\w+
	{ loc = fx($0, $1); ext = Ext::fx($0, $1); };

testRef :=
	^\w+ ^\w+
	{ ref($1) = $0; };

testCall :=
	^[.\w]+ ^\w+ ^\w+
	{ value = call($2, $1, $0); };

testCallRef :=
	'^\w+':var '(' '^\w+':val ')'
	{ call('ref', var) = val; }; 

testCallCall :=
	'^\w+':var '(' '^\w+':val ')'
	{ call('call', 'ref', var) = val; };

testSwap :=
	'^\w+':first '^\w+':second
	{
		swap(first, second);
		self({value: "$first,$second"});
	};

testNth :=
	'^\w+'+ ^\d+
	{ value = nth($i, $1, $2, $3, $4); };
